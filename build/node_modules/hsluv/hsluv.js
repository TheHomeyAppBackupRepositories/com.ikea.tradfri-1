// Generated by Haxe 3.4.4
var hsluv = hsluv || {};
hsluv.Geometry = function() { };
hsluv.Geometry.intersectLineLine = function(a, b) {
  const x = (a.intercept - b.intercept) / (b.slope - a.slope);
  const y = a.slope * x + a.intercept;
  return { x, y };
};
hsluv.Geometry.distanceFromOrigin = function(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
};
hsluv.Geometry.distanceLineFromOrigin = function(line) {
  return Math.abs(line.intercept) / Math.sqrt(Math.pow(line.slope, 2) + 1);
};
hsluv.Geometry.perpendicularThroughPoint = function(line, point) {
  const slope = -1 / line.slope;
  const intercept = point.y - slope * point.x;
  return { slope, intercept };
};
hsluv.Geometry.angleFromOrigin = function(point) {
  return Math.atan2(point.y, point.x);
};
hsluv.Geometry.normalizeAngle = function(angle) {
  const m = 2 * Math.PI;
  return (angle % m + m) % m;
};
hsluv.Geometry.lengthOfRayUntilIntersect = function(theta, line) {
  return line.intercept / (Math.sin(theta) - line.slope * Math.cos(theta));
};
hsluv.Hsluv = function() { };
hsluv.Hsluv.getBounds = function(L) {
  const result = [];
  const sub1 = Math.pow(L + 16, 3) / 1560896;
  const sub2 = sub1 > hsluv.Hsluv.epsilon ? sub1 : L / hsluv.Hsluv.kappa;
  let _g = 0;
  while (_g < 3) {
    const c = _g++;
    const m1 = hsluv.Hsluv.m[c][0];
    const m2 = hsluv.Hsluv.m[c][1];
    const m3 = hsluv.Hsluv.m[c][2];
    let _g1 = 0;
    while (_g1 < 2) {
      const t = _g1++;
      const top1 = (284517 * m1 - 94839 * m3) * sub2;
      const top2 = (838422 * m3 + 769860 * m2 + 731718 * m1) * L * sub2 - 769860 * t * L;
      const bottom = (632260 * m3 - 126452 * m2) * sub2 + 126452 * t;
      result.push({ slope: top1 / bottom, intercept: top2 / bottom });
    }
  }
  return result;
};
hsluv.Hsluv.maxSafeChromaForL = function(L) {
  const bounds = hsluv.Hsluv.getBounds(L);
  let min = Infinity;
  let _g = 0;
  while (_g < bounds.length) {
    const bound = bounds[_g];
    ++_g;
    const length = hsluv.Geometry.distanceLineFromOrigin(bound);
    min = Math.min(min, length);
  }
  return min;
};
hsluv.Hsluv.maxChromaForLH = function(L, H) {
  const hrad = H / 360 * Math.PI * 2;
  const bounds = hsluv.Hsluv.getBounds(L);
  let min = Infinity;
  let _g = 0;
  while (_g < bounds.length) {
    const bound = bounds[_g];
    ++_g;
    const length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad, bound);
    if (length >= 0) {
      min = Math.min(min, length);
    }
  }
  return min;
};
hsluv.Hsluv.dotProduct = function(a, b) {
  let sum = 0;
  let _g1 = 0;
  const _g = a.length;
  while (_g1 < _g) {
    const i = _g1++;
    sum += a[i] * b[i];
  }
  return sum;
};
hsluv.Hsluv.fromLinear = function(c) {
  if (c <= 0.0031308) {
    return 12.92 * c;
  }
  return 1.055 * Math.pow(c, 0.416666666666666685) - 0.055;
};
hsluv.Hsluv.toLinear = function(c) {
  if (c > 0.04045) {
    return Math.pow((c + 0.055) / 1.055, 2.4);
  }
  return c / 12.92;
};
hsluv.Hsluv.xyzToRgb = function(tuple) {
  return [hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0], tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1], tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2], tuple))];
};
hsluv.Hsluv.rgbToXyz = function(tuple) {
  const rgbl = [hsluv.Hsluv.toLinear(tuple[0]), hsluv.Hsluv.toLinear(tuple[1]), hsluv.Hsluv.toLinear(tuple[2])];
  return [hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0], rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1], rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2], rgbl)];
};
hsluv.Hsluv.yToL = function(Y) {
  if (Y <= hsluv.Hsluv.epsilon) {
    return Y / hsluv.Hsluv.refY * hsluv.Hsluv.kappa;
  }
  return 116 * Math.pow(Y / hsluv.Hsluv.refY, 0.333333333333333315) - 16;
};
hsluv.Hsluv.lToY = function(L) {
  if (L <= 8) {
    return hsluv.Hsluv.refY * L / hsluv.Hsluv.kappa;
  }
  return hsluv.Hsluv.refY * Math.pow((L + 16) / 116, 3);
};
hsluv.Hsluv.xyzToLuv = function(tuple) {
  const X = tuple[0];
  const Y = tuple[1];
  const Z = tuple[2];
  const divider = X + 15 * Y + 3 * Z;
  let varU = 4 * X;
  let varV = 9 * Y;
  if (divider != 0) {
    varU /= divider;
    varV /= divider;
  } else {
    varU = NaN;
    varV = NaN;
  }
  const L = hsluv.Hsluv.yToL(Y);
  if (L == 0) {
    return [0, 0, 0];
  }
  const U = 13 * L * (varU - hsluv.Hsluv.refU);
  const V = 13 * L * (varV - hsluv.Hsluv.refV);
  return [L, U, V];
};
hsluv.Hsluv.luvToXyz = function(tuple) {
  const L = tuple[0];
  const U = tuple[1];
  const V = tuple[2];
  if (L == 0) {
    return [0, 0, 0];
  }
  const varU = U / (13 * L) + hsluv.Hsluv.refU;
  const varV = V / (13 * L) + hsluv.Hsluv.refV;
  const Y = hsluv.Hsluv.lToY(L);
  const X = 0 - 9 * Y * varU / ((varU - 4) * varV - varU * varV);
  const Z = (9 * Y - 15 * varV * Y - varV * X) / (3 * varV);
  return [X, Y, Z];
};
hsluv.Hsluv.luvToLch = function(tuple) {
  const L = tuple[0];
  const U = tuple[1];
  const V = tuple[2];
  const C = Math.sqrt(U * U + V * V);
  let H;
  if (C < 0.00000001) {
    H = 0;
  } else {
    const Hrad = Math.atan2(V, U);
    H = Hrad * 180.0 / Math.PI;
    if (H < 0) {
      H = 360 + H;
    }
  }
  return [L, C, H];
};
hsluv.Hsluv.lchToLuv = function(tuple) {
  const L = tuple[0];
  const C = tuple[1];
  const H = tuple[2];
  const Hrad = H / 360.0 * 2 * Math.PI;
  const U = Math.cos(Hrad) * C;
  const V = Math.sin(Hrad) * C;
  return [L, U, V];
};
hsluv.Hsluv.hsluvToLch = function(tuple) {
  const H = tuple[0];
  const S = tuple[1];
  const L = tuple[2];
  if (L > 99.9999999) {
    return [100, 0, H];
  }
  if (L < 0.00000001) {
    return [0, 0, H];
  }
  const max = hsluv.Hsluv.maxChromaForLH(L, H);
  const C = max / 100 * S;
  return [L, C, H];
};
hsluv.Hsluv.lchToHsluv = function(tuple) {
  const L = tuple[0];
  const C = tuple[1];
  const H = tuple[2];
  if (L > 99.9999999) {
    return [H, 0, 100];
  }
  if (L < 0.00000001) {
    return [H, 0, 0];
  }
  const max = hsluv.Hsluv.maxChromaForLH(L, H);
  const S = C / max * 100;
  return [H, S, L];
};
hsluv.Hsluv.hpluvToLch = function(tuple) {
  const H = tuple[0];
  const S = tuple[1];
  const L = tuple[2];
  if (L > 99.9999999) {
    return [100, 0, H];
  }
  if (L < 0.00000001) {
    return [0, 0, H];
  }
  const max = hsluv.Hsluv.maxSafeChromaForL(L);
  const C = max / 100 * S;
  return [L, C, H];
};
hsluv.Hsluv.lchToHpluv = function(tuple) {
  const L = tuple[0];
  const C = tuple[1];
  const H = tuple[2];
  if (L > 99.9999999) {
    return [H, 0, 100];
  }
  if (L < 0.00000001) {
    return [H, 0, 0];
  }
  const max = hsluv.Hsluv.maxSafeChromaForL(L);
  const S = C / max * 100;
  return [H, S, L];
};
hsluv.Hsluv.rgbToHex = function(tuple) {
  let h = '#';
  let _g = 0;
  while (_g < 3) {
    const i = _g++;
    const chan = tuple[i];
    const c = Math.round(chan * 255);
    const digit2 = c % 16;
    const digit1 = (c - digit2) / 16 | 0;
    h += hsluv.Hsluv.hexChars.charAt(digit1) + hsluv.Hsluv.hexChars.charAt(digit2);
  }
  return h;
};
hsluv.Hsluv.hexToRgb = function(hex) {
  hex = hex.toLowerCase();
  const ret = [];
  let _g = 0;
  while (_g < 3) {
    const i = _g++;
    const digit1 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 1));
    const digit2 = hsluv.Hsluv.hexChars.indexOf(hex.charAt(i * 2 + 2));
    const n = digit1 * 16 + digit2;
    ret.push(n / 255.0);
  }
  return ret;
};
hsluv.Hsluv.lchToRgb = function(tuple) {
  return hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple)));
};
hsluv.Hsluv.rgbToLch = function(tuple) {
  return hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple)));
};
hsluv.Hsluv.hsluvToRgb = function(tuple) {
  return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple));
};
hsluv.Hsluv.rgbToHsluv = function(tuple) {
  return hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple));
};
hsluv.Hsluv.hpluvToRgb = function(tuple) {
  return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple));
};
hsluv.Hsluv.rgbToHpluv = function(tuple) {
  return hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple));
};
hsluv.Hsluv.hsluvToHex = function(tuple) {
  return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple));
};
hsluv.Hsluv.hpluvToHex = function(tuple) {
  return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple));
};
hsluv.Hsluv.hexToHsluv = function(s) {
  return hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s));
};
hsluv.Hsluv.hexToHpluv = function(s) {
  return hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s));
};
hsluv.Hsluv.m = [[3.240969941904521, -1.537383177570093, -0.498610760293], [-0.96924363628087, 1.87596750150772, 0.041555057407175], [0.055630079696993, -0.20397695888897, 1.056971514242878]];
hsluv.Hsluv.minv = [[0.41239079926595, 0.35758433938387, 0.18048078840183], [0.21263900587151, 0.71516867876775, 0.072192315360733], [0.019330818715591, 0.11919477979462, 0.95053215224966]];
hsluv.Hsluv.refY = 1.0;
hsluv.Hsluv.refU = 0.19783000664283;
hsluv.Hsluv.refV = 0.46831999493879;
hsluv.Hsluv.kappa = 903.2962962;
hsluv.Hsluv.epsilon = 0.0088564516;
hsluv.Hsluv.hexChars = '0123456789abcdef';
const root = {
  'hsluvToRgb': hsluv.Hsluv.hsluvToRgb,
  'rgbToHsluv': hsluv.Hsluv.rgbToHsluv,
  'hpluvToRgb': hsluv.Hsluv.hpluvToRgb,
  'rgbToHpluv': hsluv.Hsluv.rgbToHpluv,
  'hsluvToHex': hsluv.Hsluv.hsluvToHex,
  'hexToHsluv': hsluv.Hsluv.hexToHsluv,
  'hpluvToHex': hsluv.Hsluv.hpluvToHex,
  'hexToHpluv': hsluv.Hsluv.hexToHpluv,
  'lchToHpluv': hsluv.Hsluv.lchToHpluv,
  'hpluvToLch': hsluv.Hsluv.hpluvToLch,
  'lchToHsluv': hsluv.Hsluv.lchToHsluv,
  'hsluvToLch': hsluv.Hsluv.hsluvToLch,
  'lchToLuv': hsluv.Hsluv.lchToLuv,
  'luvToLch': hsluv.Hsluv.luvToLch,
  'xyzToLuv': hsluv.Hsluv.xyzToLuv,
  'luvToXyz': hsluv.Hsluv.luvToXyz,
  'xyzToRgb': hsluv.Hsluv.xyzToRgb,
  'rgbToXyz': hsluv.Hsluv.rgbToXyz,
  'lchToRgb': hsluv.Hsluv.lchToRgb,
  'rgbToLch': hsluv.Hsluv.rgbToLch,
};

module.exports = root;
