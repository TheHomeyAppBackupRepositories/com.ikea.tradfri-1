/**
 * HSV optimized for shaders
 * http://chilliant.blogspot.ca/2012/08/rgbhcy-in-hlsl.html
 *
 * @module color-space/hcy
 */

'use strict';


const loop = require('mumath/mod');
const clamp = require('mumath/clamp');
const rgb = require('./rgb');


const hcy = module.exports = {
  name: 'hcy',
  min: [0, 0, 0],
  max: [360, 100, 255],
  channel: ['hue', 'chroma', 'luminance'],
  alias: ['HCY'],
};


/**
 * HCY to RGB
 *
 * @param {Array} hcy Channel values
 *
 * @return {Array} RGB channel values
 */
hcy.rgb = function(hcy) {
  let h = loop(hcy[0], 0, 360) * Math.PI / 180;
  const s = clamp(hcy[1], 0, 100) / 100;
  const i = clamp(hcy[2], 0, 255) / 255;

  const pi3 = Math.PI / 3;

  let r; let g; let
    b;
  if (h < (2 * pi3)) {
    b = i * (1 - s);
    r = i * (1 + (s * Math.cos(h) / Math.cos(pi3 - h)));
    g = i * (1 + (s * (1 - Math.cos(h) / Math.cos(pi3 - h))));
  } else if (h < (4 * pi3)) {
    h -= 2 * pi3;
    r = i * (1 - s);
    g = i * (1 + (s * Math.cos(h) / Math.cos(pi3 - h)));
    b = i * (1 + (s * (1 - Math.cos(h) / Math.cos(pi3 - h))));
  } else {
    h -= 4 * pi3;
    g = i * (1 - s);
    b = i * (1 + (s * Math.cos(h) / Math.cos(pi3 - h)));
    r = i * (1 + (s * (1 - Math.cos(h) / Math.cos(pi3 - h))));
  }

  return [r * 255, g * 255, b * 255];
};


/**
 * RGB to HCY
 *
 * @param {Array} rgb Channel values
 *
 * @return {Array} HCY channel values
 */
rgb.hcy = function(rgb) {
  const sum = rgb[0] + rgb[1] + rgb[2];

  const r = rgb[0] / sum;
  const g = rgb[1] / sum;
  const b = rgb[2] / sum;

  let h = Math.acos(
    (0.5 * ((r - g) + (r - b)))
		/ Math.sqrt((r - g) * (r - g) + (r - b) * (g - b)),
  );
  if (b > g) {
    h = 2 * Math.PI - h;
  }

  const s = 1 - 3 * Math.min(r, g, b);

  const i = sum / 3;

  return [h * 180 / Math.PI, s * 100, i];
};
